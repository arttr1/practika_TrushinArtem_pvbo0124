# Практические работы по дисциплине "Введение в алгоритмы и структуры данных систем реального времени"

Репозиторий содержит практические работы по Java, охватывающие основы программирования, объектно-ориентированное программирование, коллекции, исключения, дженерики, паттерны проектирования и структуры данных.

---

## Практика 1: Основы Java

**Расположение:** `practika1/src/Main.java`

**Описание:** Базовые операции с массивами, форматированный вывод и функции.

**Задания:**
- Задание 3: Вычисление суммы и среднего арифметического элементов массива
- Задание 6: Вывод первых 10 элементов гармонического ряда (1/1, 1/2, ..., 1/10)
- Задание 7: Реализация функции вычисления факториала числа

**Решение и логика:**

**Задание 3:** Алгоритм простой - в цикле суммируются все элементы массива, затем сумма делится на количество элементов. Используется `float` для точности вычислений среднего значения.

**Задание 6:** Используется цикл `for` от 1 до 10, на каждой итерации вычисляется `1.0/i` (деление на double для получения вещественного результата). Форматирование через `printf` с точностью до 2 знаков после запятой.

**Задание 7:** Факториал вычисляется итеративно через цикл `for`. Базовый случай: если `n == 0` или `n == 1`, возвращается 1. Иначе перемножаются числа от 2 до n включительно. Временная сложность: O(n).

---

## Практика 2: Классы и объекты

**Расположение:** `practika2/src/`

**Описание:** Работа с классами, создание объектов и массивов объектов.

**Реализованные классы:**
- `Point` - класс для представления точки на плоскости
- `Circle` - класс для представления окружности (центр и радиус)
- `Tester` - класс для хранения массива окружностей
- `Poker` - программа раздачи карт для игры в покер

**Основные задачи:**
- Создание классов с конструкторами
- Работа с массивами объектов
- Реализация программы раздачи карт из колоды

**Решение и логика:**

**Класс Point:** Реализован с двумя конструкторами - параметризованным и по умолчанию (инициализация нулями). Методы `setX()`, `setY()` для изменения координат, `show()` для вывода, `get()` возвращает массив координат.

**Класс Circle:** Использует композицию - содержит объект `Point` как центр. Конструктор принимает центр и радиус. Геттеры для доступа к полям.

**Класс Tester:** Реализует контейнер для массива окружностей фиксированного размера. Метод `addCircle()` проверяет наличие места перед добавлением. Используется счётчик `count` для отслеживания количества элементов.

**Poker:** Алгоритм создания колоды: два вложенных цикла создают все комбинации мастей и достоинств. Используется `ArrayList` для динамического хранения. `Collections.shuffle()` перемешивает колоду. Раздача происходит по 5 карт каждому игроку с проверкой достаточности карт в колоде.

---

## Практика 3: Пакеты, обёртки, форматирование

**Расположение:** `practika3/src/`

### Задание: MathRandom
**Файл:** `practika3/src/MathRandom/Main.java`

**Описание:** Работа с классами `Circle` и `Tester`, использование `Random` для генерации случайных координат точек.

**Функционал:**
- Создание окружностей со случайными координатами
- Поиск окружности с максимальным и минимальным радиусом
- Сортировка окружностей по радиусу

**Решение и логика:** Используется класс `Random` для генерации случайных координат. Радиус вычисляется как расстояние между двумя случайными точками. Поиск максимума/минимума реализован через линейный поиск по массиву. Сортировка выполняется стандартным методом `sort()` с компаратором по радиусу.

### Задание: Obolochki (Обёртки)
**Файл:** `practika3/src/Obolochki/Main.java`

**Описание:** Работа с классами-обёртками (`Double`).

**Задачи:**
- Создание объектов `Double` через `valueOf()`
- Парсинг строки в `Double` через `parseDouble()`
- Преобразование `Double` в примитивные типы (byte, short, int, long, float, double)
- Преобразование `Double` в строку

**Решение и логика:** Демонстрация работы с классами-обёртками. `valueOf()` создаёт объект из строки, `parseDouble()` парсит строку в примитив. Методы `*Value()` выполняют преобразование в соответствующие примитивные типы (возможна потеря точности при преобразовании в меньшие типы). `toString()` преобразует объект обратно в строку.

### Задание: Форматированный вывод
**Файл:** `practika3/src/report_FormattedOutputTask/Main.java`

**Описание:** Форматированный вывод информации о сотрудниках с зарплатами.

**Функционал:**
- Класс `Employee` с именем и зарплатой
- Класс `Report` для генерации отчёта с форматированием чисел

---

## Практика 4: Наследование и полиморфизм

**Расположение:** `practika4/src/`

### Задание: Абстрактные классы
**Файл:** `practika4/src/abstract_classes/Main.java`

**Описание:** Реализация иерархии геометрических фигур через абстрактные классы.

**Классы:**
- `Shape` - абстрактный базовый класс
- `Rectangle` - прямоугольник
- `Square` - квадрат (наследуется от `Rectangle`)
- `Circle` - окружность

**Методы:**
- `getArea()` - вычисление площади
- `getPerimetr()` - вычисление периметра
- `getType()` - получение типа фигуры

**Решение и логика:** Использование абстрактного класса `Shape` с абстрактными методами обеспечивает полиморфизм - все фигуры можно обрабатывать единообразно через ссылку на `Shape`. Каждый подкласс реализует методы по-своему: `Rectangle` вычисляет площадь как `a*b`, периметр как `2*(a+b)`. `Square` наследуется от `Rectangle` и использует один параметр для обеих сторон. `Circle` использует формулу площади `π*r²` и периметра `2πr`. Полиморфизм позволяет вызывать методы через ссылку на базовый класс, не зная конкретного типа объекта.

### Задание: Перечисления (Enums)
**Файл:** `practika4/src/seasons/Main.java`

**Описание:** Реализация перечисления времён года с дополнительными полями и методами.

**Функционал:**
- Перечисление `Season` с полями средней температуры
- Переопределение метода `getDescript()` для лета
- Метод `favMessage()` для вывода сообщения о любимом времени года

**Решение и логика:** Enum в Java - это полноценный класс. Константы перечисления могут иметь поля (средняя температура) и методы. Конструктор принимает температуру и сохраняет её в поле. Метод `getDescript()` имеет реализацию по умолчанию ("cold season"), но для `SUMMER` переопределён ("warm season"). Метод `favMessage()` использует `switch` для вывода сообщения в зависимости от времени года. `Season.values()` возвращает массив всех констант для итерации.

### Задание: Класс Phone
**Файл:** `practika4/src/phone/Main.java`

**Описание:** Реализация класса `Phone` с методами для работы с телефонными звонками и сообщениями.

**Функционал:**
- Хранение номера телефона и модели
- Метод `receiveCall()` для приёма звонка
- Метод `sendMessage()` для отправки сообщений на несколько номеров

---

## Практика 5: Графический интерфейс (Swing)

**Расположение:** `practika5/src/MatchScoreGUI.java`

**Описание:** Создание GUI приложения для отслеживания счёта футбольного матча.

**Функционал:**
- Кнопки для увеличения счёта команд AC Milan и Real Madrid
- Отображение текущего счёта
- Отображение последнего забившего
- Определение победителя или ничьей

**Технологии:** Java Swing, обработка событий

**Решение и логика:** Использование паттерна "Observer" через `ActionListener`. При нажатии кнопки вызывается `actionPerformed()`, который увеличивает соответствующий счёт и вызывает `updateLabels()`. Метод `updateLabels()` обновляет все три метки: счёт (формат "X X Y"), последний забивший, победитель (сравнение счётов). Используется `GridLayout` для вертикального расположения компонентов. Состояние хранится в полях класса (`milanScore`, `madridScore`), что обеспечивает сохранение данных между событиями.

---

## Практика 6: Интерфейсы

**Расположение:** `practika6/src/`

### Задание: Movable интерфейс
**Файл:** `practika6/src/tasks1_2/Main.java`

**Описание:** Реализация интерфейса `Movable` для перемещаемых объектов.

**Классы:**
- `Movable` - интерфейс с методами `moveUp()`, `moveDown()`, `moveLeft()`, `moveRight()`
- `MovablePoint` - точка, которая может перемещаться
- `MovableCircle` - окружность с перемещаемым центром

**Решение и логика:** Интерфейс определяет контракт для перемещаемых объектов. `MovablePoint` хранит координаты и скорости по осям. Методы перемещения изменяют координаты на соответствующую скорость. `MovableCircle` использует композицию - содержит `MovablePoint` как центр и делегирует ему все вызовы методов перемещения. Это демонстрирует паттерн "Делегирование" - окружность не реализует логику перемещения самостоятельно, а использует точку. Полиморфизм позволяет обрабатывать разные типы перемещаемых объектов через ссылку на интерфейс.

### Задание: Payment система
**Файл:** `practika6/src/Payment/Main.java`

**Описание:** Система обработки платежей через различные методы оплаты.

**Классы:**
- `PaymentMethod` - интерфейс для методов оплаты
- `CreditCard` - оплата кредитной картой
- `PayPal` - оплата через PayPal
- `CheckOut` - класс для обработки заказов

**Решение и логика:** Паттерн "Стратегия" - различные алгоритмы оплаты инкапсулированы в отдельные классы, реализующие общий интерфейс. `CheckOut.ProcessOrder()` принимает сумму и объект `PaymentMethod`, не зная конкретного типа. Каждый класс (`CreditCard`, `PayPal`) реализует метод `pay()` по-своему. Это позволяет легко добавлять новые методы оплаты без изменения кода `CheckOut`. Полиморфизм обеспечивает единообразную обработку разных способов оплаты.

---

## Практика 7: Интерфейсы (продолжение)

**Расположение:** `practika7/src/`

**Описание:** Расширенная реализация интерфейса `movable`.

**Классы:**
- `movable` - интерфейс для перемещаемых объектов
- `movablePoint` - перемещаемая точка с координатами и скоростью
- `movableRectangle` - перемещаемый прямоугольник, состоящий из двух точек

**Особенности:**
- Проверка совпадения скоростей точек прямоугольника перед перемещением

---

## Практика 8: Рекурсия

**Расположение:** `practika8/src/`

### Задание 1
**Файл:** `practika8/src/task1.java`

**Описание:** Вывод последовательности чисел вида: 1 2 2 3 3 3 ... (каждое число повторяется столько раз, каково его значение).

**Решение и логика:** Итеративный подход с двумя счётчиками: `i` - текущее число для вывода, `count` - сколько раз уже вывели текущее число. Когда `count == i`, переходим к следующему числу и сбрасываем счётчик. Временная сложность: O(√n), где n - количество выведенных чисел.

### Задание 3
**Файл:** `practika8/src/task3.java`

**Описание:** Рекурсивный вывод всех чисел от `a` до `b` включительно.

**Решение и логика:** Рекурсивная функция `solution()` с базовым случаем `a == b`. Если `a < b`, выводим `a` и рекурсивно вызываем с `a+1`. Если `a > b`, выводим `a` и вызываем с `a-1`. Глубина рекурсии: |a-b|+1.

### Задание 4
**Файл:** `practika8/src/task4.java`

**Описание:** Подсчёт количества k-значных чисел, сумма цифр которых равна s (первая цифра не может быть нулём).

**Решение и логика:** Рекурсивный перебор всех возможных комбинаций цифр. Параметр `first` определяет, является ли текущая цифра первой (не может быть 0). На каждом уровне рекурсии перебираем цифры от `start` (0 или 1) до 9, уменьшая оставшуюся сумму. Базовый случай: когда набрано k цифр и сумма равна 0. Временная сложность: O(10^k) в худшем случае.

### Задание 6
**Файл:** `practika8/src/task6.java`

**Описание:** Рекурсивная проверка числа на простоту.

**Решение и логика:** Рекурсивная функция `isPrime()` проверяет делимость на числа от 2 до √n. Базовый случай: если `d*d > n`, число простое. Если `n % d == 0`, число составное. Иначе рекурсивно проверяем следующий делитель. Оптимизация: проверка только до √n, так как если есть делитель больше √n, то есть и меньший. Временная сложность: O(√n).

### Задание 8
**Файл:** `practika8/src/task8.java`

**Описание:** Проверка строки на палиндром.

**Решение и логика:** Итеративный подход: сравниваем символы с начала и конца строки, двигаясь к центру. Сравниваем `word[i]` с `word[length-1-i]` для i от 0 до length/2. Если все пары совпадают, строка - палиндром. Временная сложность: O(n), где n - длина строки.

---

## Практика 9: Алгоритмы сортировки

**Расположение:** `practika9/src/`

**Описание:** Реализация различных алгоритмов сортировки для объектов `Student`.

**Алгоритмы:**
- `InsertionSort` - сортировка вставками
- `MergeSort` - сортировка слиянием
- `QuickSort` - быстрая сортировка

**Класс Student:**
- Поля: `iDNumber`, `name`, `GPA`
- Реализует интерфейс `MyComparable<Student>`
- Поддержка сортировки по ID или GPA

**Функционал:**
- Сортировка списка студентов по ID
- Объединение двух списков и сортировка
- Сортировка по GPA в порядке убывания

**Решение и логика:**

**InsertionSort:** Алгоритм работает как сортировка карт в руке. Для каждого элемента (начиная со второго) находим правильную позицию среди уже отсортированных элементов слева, сдвигая большие элементы вправо. Временная сложность: O(n²) в худшем случае, O(n) для почти отсортированных данных. Пространственная: O(1).

**MergeSort:** Разделяй и властвуй. Рекурсивно разбиваем список пополам до базового случая (1 элемент), затем сливаем отсортированные части. Функция `merge()` использует два указателя для объединения двух отсортированных списков. Временная сложность: O(n log n) всегда. Пространственная: O(n) для дополнительных списков.

**QuickSort:** Разделяй и властвуй с выбором опорного элемента (pivot). Функция `partition()` размещает элементы меньше pivot слева, больше - справа. Рекурсивно сортируем левую и правую части. Временная сложность: O(n log n) в среднем, O(n²) в худшем случае. Пространственная: O(log n) для стека рекурсии.

**Student.compareTo():** Использует статическое поле `compareBy` для выбора критерия сравнения. При сортировке по GPA используется обратный порядок (убывание) через `Double.compare(other.GPA, this.GPA)`.

---

## Практика 10: Сортировка студентов

**Расположение:** `practika10/src/`

**Описание:** Расширенная система работы со студентами и их сортировки.

**Класс Student:**
- Расширенные поля: ID, имя, фамилия, специальность, курс, группа, GPA
- Геттеры и сеттеры для всех полей

**Класс StudentSorter:**
- Методы сортировки по различным критериям
- Быстрая сортировка по ID
- Сортировка по фамилии
- Объединение списков студентов

---

## Практика 11: Работа с датами и временем

**Расположение:** `practika11/src/`

### Задание 1: Assignment и Developer
**Файл:** `practika11/src/task1/Main.java`

**Описание:** Работа с датами получения и сдачи задания.

**Классы:**
- `Developer` - разработчик с фамилией
- `Assignment` - задание с датами получения и сдачи
- Использование `LocalDateTime` и форматирование дат

### Задание 2: Сравнение дат
**Файл:** `practika11/src/task2/Main.java`

**Описание:** Сравнение текущей даты с датой, введённой пользователем.

**Функционал:**
- Ввод даты пользователем через `UserInput`
- Сравнение дат через `DateComparator`
- Вывод результата сравнения

### Задание 3: Форматирование даты рождения студента
**Файл:** `practika11/src/task3/Main.java`

**Описание:** Работа с датами рождения студентов и их форматированием.

**Функционал:**
- Класс `Student` с датой рождения (`LocalDate`)
- Методы форматирования даты: короткий, средний, полный формат

### Задание 4: Date и Calendar
**Файл:** `practika11/src/task4/Main.java`

**Описание:** Демонстрация работы с классами `Date` и `Calendar`.

**Функционал:**
- Ввод даты и времени пользователем
- Создание объектов `Date` и `Calendar`
- Вывод результатов работы с датами

---

## Практика 13: Регулярные выражения - форматирование телефонов

**Расположение:** `practika13/`

**Описание:** Форматирование телефонных номеров в единый формат.

**Функционал:**
- Поддержка форматов: `+7XXXXXXXXXX`, `8XXXXXXXXXX`, `+XX...`
- Преобразование в формат: `+X XXX-XXX-XXXX`
- Валидация номеров
- Обработка различных кодов стран

**Класс:** `PhoneNumberFormatter`

**Решение и логика:** Алгоритм нормализации: сначала определяем формат входа (начинается с "8" или "+"), затем извлекаем только цифры. Для формата "8" заменяем первую цифру на "7" (код страны). Для формата "+" извлекаем код страны (1-2 цифры) и номер (10 цифр). Валидация через регулярные выражения проверяет корректность длины и формата. Финальное форматирование: разделение номера на три части (XXX-XXX-XXXX) через `substring()` и объединение с дефисами. Обработка ошибок через `IllegalArgumentException` с описательными сообщениями.

---

## Практика 14: Регулярные выражения - извлечение данных

**Расположение:** `practika14/`

### Задание: Извлечение цен
**Файл:** `practika14/PriceExtractor.java`

**Описание:** Извлечение цен из текста с валютами USD, RUB, EUR.

**Функционал:**
- Поиск цен в формате: число + валюта
- Фильтрация некорректных цен (нулевые, отрицательные, слишком малые)
- Поддержка валют: USD, RUB, EUR

**Решение и логика:** Регулярное выражение `\\b(\\d+(?:\\.\\d{1,2})?)\\s+(USD|RUB|EUR)\\b` использует границы слов `\\b` для точного совпадения. Группа `(\\d+(?:\\.\\d{1,2})?)` захватывает число с опциональной дробной частью (1-2 знака). Группа `(USD|RUB|EUR)` захватывает валюту. `Matcher.find()` находит все совпадения в тексте. После извлечения выполняется валидация: проверка на положительное значение и минимальный порог (0.01). Некорректные цены отфильтровываются. Результат собирается в список строк формата "число валюта".

### Задание: Разбиение строк
**Файл:** `practika14/StringSplitter.java`

**Описание:** Интерактивная программа для разбиения строк по регулярным выражениям.

**Функционал:**
- Ввод строки и регулярного выражения пользователем
- Разбиение строки через `split()`
- Отображение результатов разбиения
- Возможность выхода командой "exit"

---

## Практика 18: Обработка исключений

**Расположение:** `practika18/src/`

### Задание 1: ArithmeticException
**Файл:** `practika18/src/task1/Main.java`

**Описание:** Обработка деления на ноль.

**Функционал:**
- Перехват `ArithmeticException` при делении на ноль
- Вывод сообщения об ошибке

**Решение и логика:** Блок `try-catch` перехватывает исключение при делении на ноль. В catch-блоке выводится понятное сообщение об ошибке вместо аварийного завершения программы.

### Задание 2: ArrayIndexOutOfBoundsException
**Файл:** `practika18/src/task2/Main.java`

**Описание:** Обработка выхода за границы массива.

**Решение и логика:** Демонстрация обработки исключения при обращении к несуществующему индексу массива. Используется `catch` для перехвата `ArrayIndexOutOfBoundsException` с выводом информативного сообщения.

### Задание 3: NumberFormatException
**Файл:** `practika18/src/task3/Main.java`

**Описание:** Обработка ошибок преобразования строк в числа.

**Решение и логика:** При вводе нечисловой строки `Integer.parseInt()` выбрасывает `NumberFormatException`. Используется общий `catch (Exception e)` для перехвата всех исключений с выводом типа исключения и сообщения через `getClass().getSimpleName()` и `getMessage()`.

### Задание 4: NullPointerException
**Файл:** `practika18/src/task4/Main.java`

**Описание:** Обработка обращения к null-объектам.

**Решение и логика:** Демонстрация блока `finally`, который выполняется всегда, независимо от того, было ли исключение. Используется для освобождения ресурсов (закрытие Scanner). Порядок выполнения: try → catch (если есть исключение) → finally.

### Задания 5-6: ThrowsDemo1
**Файл:** `practika18/src/task5-6/Main.java`

**Описание:** Демонстрация использования `throws` для проброса исключений.

**Функционал:**
- Метод с `throws` для обработки null-ключей
- Обработка исключений в вызывающем коде

**Решение и логика:** Метод `getDetailsWithReturn()` объявлен с `throws NullPointerException` и явно выбрасывает исключение при null-ключе. Метод `printMessage()` вызывает его в try-catch блоке, демонстрируя обработку исключений на уровне вызывающего кода. Это позволяет разделить ответственность: метод генерации исключения и метод его обработки.

### Задания 7-8: ThrowsDemo2
**Файл:** `practika18/src/task7-8/Main.java`

**Описание:** Интерактивная обработка исключений с повторными попытками.

**Функционал:**
- Ввод данных с обработкой ошибок
- Повторные попытки при некорректном вводе

**Решение и логика:** Реализован цикл `while` с флагом `validInput`. При возникновении исключения выводится сообщение об ошибке, и цикл продолжается, запрашивая новый ввод. Это позволяет пользователю исправить ошибку без перезапуска программы. Метод `getDetails()` выбрасывает общее `Exception` с проверкой на null и пустую строку.

---

## Практика 19: Пользовательские исключения

**Расположение:** `practika19/src/`

### Задание 1: InvalidINNException
**Файл:** `practika19/src/task1/Main.java`

**Описание:** Создание пользовательского исключения для проверки ИНН.

**Классы:**
- `InvalidINNException` - пользовательское исключение
- `OrderService` - сервис оформления заказов с проверкой ИНН

**Валидация ИНН:**
- Проверка на null и пустую строку
- Проверка формата (только цифры)
- Проверка длины (10 или 12 символов)
- Проверка на нулевой ИНН

**Решение и логика:** Создан пользовательский класс исключения `InvalidINNException`, наследующийся от `Exception`. Метод `validateINN()` выполняет многоуровневую проверку: сначала проверяет на null, затем на пустую строку, затем через регулярное выражение `\\d+` проверяет, что строка состоит только из цифр. Проверка длины: ИНН может быть 10 цифр (для юридических лиц) или 12 (для физических). Дополнительная проверка на строку из одних нулей. При несоответствии выбрасывается `InvalidINNException` с описательным сообщением. Это позволяет точно определить причину ошибки при обработке исключения.

### Задание 2: StudentNotFoundException
**Файл:** `practika19/src/task2/Main.java`

**Описание:** Система управления группой студентов с обработкой исключений.

**Классы:**
- `Student` - студент с ФИО и средним баллом
- `LabClass` - класс для управления группой студентов
- `StudentNotFoundException` - исключение при отсутствии студента

**Функционал:**
- Добавление студентов в группу
- Сортировка по среднему баллу
- Поиск студента по ФИО с обработкой исключений

---

## Практика 20: Дженерики

**Расположение:** `practika20/src/`

### Задание: Calculator
**Файл:** `practika20/src/calculator/Main.java`

**Описание:** Универсальный калькулятор для различных числовых типов.

**Класс Calculator:**
- Методы: `sum()`, `subtract()`, `multiply()`, `divide()`
- Работа с любыми типами, наследующими `Number`
- Обработка деления на ноль

**Решение и логика:** Использование дженериков с ограничением `Number` позволяет работать с любыми числовыми типами (Integer, Double, Long, Float и т.д.). Методы принимают параметры типа `Number` и преобразуют их в `double` через `doubleValue()` для универсальности вычислений. Это обеспечивает типобезопасность и возможность работы с разными типами без перегрузки методов. При делении на ноль выбрасывается `ArithmeticException` с понятным сообщением. Все методы статические, класс служебный (приватный конструктор).

**Дополнительные классы:**
- `Matrix` - работа с матрицами
- `MinMax` - поиск минимума и максимума

### Задание: Triple
**Файл:** `practika20/src/triple/Main.java`

**Описание:** Реализация класса `Triple` для хранения трёх значений разных типов.

**Функционал:**
- Дженерик класс с тремя типами: `Triple<T, V, K>`
- Методы получения значений
- Вывод типов полей
- Поддержка `Comparable` для типа T

**Решение и логика:** Класс демонстрирует использование нескольких параметров типа в дженериках. Каждое поле имеет свой тип, что обеспечивает типобезопасность. Метод `printTypes()` использует рефлексию (`getClass()`, `getGenericSuperclass()`) для вывода информации о типах во время выполнения (с учётом type erasure). Ограничение `T extends Comparable<T>` позволяет вызывать метод `compareTo()` на объектах типа T, что полезно для сортировки и сравнения. Это демонстрирует bounded type parameters в дженериках Java.

---

## Практика 21: Дженерики и коллекции

**Расположение:** `practika21/src/`

### Задание 1: ArrayConverter
**Файл:** `practika21/src/task1/Main.java`

**Описание:** Конвертация массивов в списки с использованием дженериков.

**Функционал:**
- Перегрузка методов для разных типов массивов
- Конвертация `String[]`, `int[]`, `double[]` в `List`

**Решение и логика:** Демонстрация перегрузки методов и работы с примитивными типами. Для дженерик-массивов (`String[]`) используется `Arrays.asList()`, который создаёт фиксированный список, обёрнутый вокруг массива. Для примитивных массивов (`int[]`, `double[]`) требуется ручное преобразование через цикл, так как `Arrays.asList()` не работает с примитивами (требуются объекты-обёртки). Каждый примитивный элемент оборачивается в соответствующий класс-обёртку (`Integer`, `Double`) при добавлении в список. Это демонстрирует разницу между примитивными типами и их обёртками в контексте дженериков.

### Задание 2: GenericArray
**Файл:** `practika21/src/task2/Main.java`

**Описание:** Реализация дженерик-класса для работы с массивами.

**Функционал:**
- Дженерик класс `GenericArray<T>`
- Методы добавления и получения элементов
- Безопасная работа с типами

**Решение и логика:** Демонстрация type erasure в Java - дженерики существуют только на этапе компиляции. Внутри используется массив `Object[]`, так как нельзя создать массив дженерик-типа напрямую (`new T[capacity]` недопустимо). При добавлении элементы сохраняются как `Object`, при извлечении выполняется приведение типа `(T)` с подавлением предупреждения через `@SuppressWarnings("unchecked")`. Проверка границ массива предотвращает `IndexOutOfBoundsException`. Это демонстрирует ограничения дженериков в Java и необходимость использования `Object[]` с приведением типов.

### Задание 3: ArrayUtils
**Файл:** `practika21/src/task3/Main.java`

**Описание:** Утилитный класс для работы с массивами разных типов.

**Функционал:**
- Метод `getElement()` для получения элемента по индексу
- Работа с массивами различных типов

### Задание 4: DirectoryLister
**Файл:** `practika21/src/task4/Main.java`

**Описание:** Листинг файлов в директории.

**Функционал:**
- Получение списка файлов в директории
- Вывод первых 5 файлов
- Обработка `IOException`

### Задание 5: Solution (HashMap)
**Файл:** `practika21/src/task5/Main.java`

**Описание:** Создание `HashMap` из пар ключ-значение.

**Функционал:**
- Метод `newHashMap()` для создания карты из переменного числа аргументов
- Поддержка различных типов ключей и значений

---

## Практика 22: Стеки

**Расположение:** `practika22/src/`

### Задание 1: MyStack
**Файл:** `practika22/src/task1/Main.java`

**Описание:** Реализация дженерик-класса стека.

**Функционал:**
- Методы: `push()`, `pop()`, `peek()`, `isEmpty()`, `isFull()`, `size()`, `display()`
- Обработка переполнения и опустошения стека
- Дженерик реализация

**Решение и логика:** Реализация стека на массиве с использованием индекса `top` (изначально -1). При `push()` увеличиваем `top` и записываем элемент. При `pop()` возвращаем элемент и уменьшаем `top`. Используется массив `Object[]` для хранения (type erasure), с приведением типов при извлечении. Проверки на переполнение (`isFull()`) и пустоту (`isEmpty()`) перед операциями. Временная сложность всех операций: O(1). Пространственная: O(n), где n - capacity.

### Задание 2: Stack (java.util)
**Файл:** `practika22/src/task2/Main.java`

**Описание:** Демонстрация использования стандартного класса `Stack` из `java.util`.

**Функционал:**
- Работа со стандартным `Stack<String>`
- Методы: `push()`, `pop()`, `peek()`, `isEmpty()`, `size()`

### Задание 3: Тестирование стека
**Файл:** `practika22/src/task3/TestStack.java`

**Описание:** Тестирование реализации стека.

**Тесты:**
- Проверка `isEmpty()` и `isFull()`
- Обработка исключений при работе с пустым стеком
- Проверка стирания типов (type erasure)

---

## Практика 23: Очереди и выражения

**Расположение:** `practika23/src/`

### Задание 1: Реализация очереди (три подхода)
**Файл:** `practika23/src/task1/Main.java`

**Описание:** Реализация очереди тремя способами: модульный, ADT и ООП.

**Реализации:**
- `ArrayQueueModule` - модульный подход (статический класс)
- `ArrayQueueADT` - ADT подход (структура передаётся как параметр)
- `ArrayQueue` - ООП подход (класс с методами)

**Методы:**
- `enqueue()` - добавление элемента
- `dequeue()` - удаление элемента
- `element()` - просмотр первого элемента
- `size()`, `isEmpty()`, `clear()`

**Решение и логика:**

**ArrayQueueModule:** Все поля и методы статические, один глобальный экземпляр очереди. Индексы `front` и `rear` изначально -1 (пустая очередь). При первом добавлении `front = 0`. При удалении последнего элемента оба индекса сбрасываются в -1.

**ArrayQueueADT:** Структура данных передаётся как параметр во все методы. Позволяет работать с несколькими очередями одновременно. Инкапсуляция данных в отдельном классе, но методы статические.

**ArrayQueue:** Классический ООП подход - каждый объект имеет своё состояние. Инкапсуляция данных и методов в одном классе. Позволяет создавать множество независимых экземпляров очереди.

**Алгоритм работы:** Очередь реализована на массиве с двумя указателями. `rear` указывает на последний элемент, `front` - на первый. При добавлении увеличиваем `rear`, при удалении увеличиваем `front`. Размер вычисляется как `rear - front + 1`. Временная сложность всех операций: O(1).

### Задание 2: LinkedQueue
**Файл:** `practika23/src/task2/Main.java`

**Описание:** Реализация очереди на основе связного списка.

**Классы:**
- `Queue` - интерфейс очереди
- `AbstractQueue` - абстрактный класс
- `LinkedQueue` - реализация на связном списке

**Решение и логика:** Реализация через односвязный список с двумя указателями: `head` (начало очереди) и `tail` (конец). При `enqueue()` создаём новый узел и добавляем в конец (обновляем `tail.next`). При `dequeue()` удаляем узел из начала (обновляем `head`). Если очередь становится пустой, оба указателя устанавливаются в null. Преимущество перед массивом: динамическое расширение без ограничения размера. Временная сложность: O(1) для всех операций.

### Задание 3: Выражения
**Файл:** `practika23/src/task3/Main.java`

**Описание:** Реализация системы для вычисления арифметических выражений.

**Классы:**
- `Expression` - интерфейс выражения
- `Const` - константа
- `Variable` - переменная
- `AbstractBinaryOperation` - абстрактная бинарная операция
- `Add`, `Subtract`, `Multiply`, `Divide` - операции

**Пример:** Вычисление выражения `x^2 - 2*x + 1`

**Решение и логика:** Реализация паттерна "Компоновщик" (Composite) для представления дерева выражений. Каждый узел реализует интерфейс `Expression` с методом `evaluate(x)`. Листья: `Const` (возвращает константу) и `Variable` (возвращает значение переменной). Внутренние узлы: бинарные операции, которые рекурсивно вычисляют левый и правый операнды, затем применяют операцию. Выражение `x^2 - 2*x + 1` строится как: `Add(Subtract(Multiply(Variable, Variable), Multiply(Const(2), Variable)), Const(1))`. Вычисление происходит через обход дерева в глубину. Временная сложность: O(n), где n - количество узлов в дереве.

---

## Практика 24: Паттерны проектирования

**Расположение:** `practika24/src/`

### Задание 1: Factory Method (Фабричный метод)
**Файл:** `practika24/src/task1/Main.java`

**Описание:** Реализация паттерна "Фабричный метод" для создания компьютеров.

**Классы:**
- `Computer` - абстрактный класс компьютера
- `PC` - класс персонального компьютера
- `Server` - класс сервера
- `ComputerFactory` - фабрика для создания компьютеров

**Функционал:**
- Создание объектов через фабрику
- Различные конфигурации для PC и Server

**Решение и логика:** Паттерн "Фабричный метод" инкапсулирует создание объектов. Клиентский код вызывает `ComputerFactory.getComputer()` с типом и параметрами, не зная конкретных классов. Фабрика на основе строки типа создаёт соответствующий объект (`PC` или `Server`). Это упрощает добавление новых типов компьютеров и централизует логику создания. `Computer` - абстрактный класс с абстрактными методами `getRAM()`, `getHDD()`, `getCPU()`, которые реализуются в подклассах.

### Задание 2: Factory Method (Текстовый редактор)
**Файл:** `practika24/src/task2/Main.java`

**Описание:** Применение паттерна "Фабричный метод" для создания документов в текстовом редакторе.

**Классы:**
- `Document` - интерфейс документа
- `TextDocument` - текстовый документ
- `CreateTextDocument` - фабрика документов
- `EditorFrame` - окно редактора

### Задание 3: Factory Method (дополнительное задание)
**Файл:** `practika24/src/task3/Main.java`

**Описание:** Дополнительная реализация паттерна "Фабричный метод".

---

## Практика 25: Регулярные выражения (продолжение)

**Расположение:** `practika25/`

### Задание 1: Проверка строки
**Файл:** `practika25/task1/Main.java`

**Описание:** Проверка строки на точное совпадение с шаблоном `abcdefghijklmnopqrstuv18340`.

**Функционал:**
- Валидация строки через регулярное выражение
- Проверка на точное совпадение (с учётом регистра и длины)

**Решение и логика:** Используется регулярное выражение `^abcdefghijklmnopqrstuv18340$`, где `^` - начало строки, `$` - конец строки. Это обеспечивает точное совпадение всей строки, а не частичное. Метод `matches()` проверяет полное совпадение. Компиляция паттерна через `Pattern.compile()` для переиспользования. Проверка чувствительна к регистру и длине строки.

### Задание 2: Извлечение цен
**Файл:** `practika25/task2/Main.java`

**Описание:** Извлечение цен из текста с валютами USD, RUB, EUR.

**Функционал:**
- Поиск цен в формате: число + пробел + валюта
- Поддержка валют: USD, RUB, EUR

### Задание 3: Проверка цифр
**Файл:** `practika25/task3/Main.java`

**Описание:** Проверка наличия цифр, за которыми не стоит знак '+'.

**Функционал:**
- Использование negative lookahead: `\d(?!\+)`
- Поиск цифр, не следующих за плюсом

**Решение и логика:** Используется negative lookahead `(?!\+)` - проверка, что после цифры НЕ следует знак '+'. Конструкция `\d(?!\+)` находит цифру, за которой не стоит плюс. `\d` - любая цифра, `(?!...)` - negative lookahead (проверка без включения в совпадение), `\+` - экранированный плюс. Метод `find()` ищет хотя бы одно совпадение в строке. Это полезно для проверки формата выражений.

### Задание 4: Валидация даты
**Файл:** `practika25/task4/Main.java`

**Описание:** Проверка даты в формате `dd/mm/yyyy`.

**Функционал:**
- Валидация формата через регулярное выражение
- Проверка корректности даты (включая високосные годы)
- Диапазон годов: 1900-9999

**Решение и логика:** Двухэтапная валидация: сначала проверка формата через regex `^([0-2]\\d|3[01])/(0[1-9]|1[0-2])/([1-9]\\d{3})$`, затем проверка корректности даты через `LocalDate.of()`. Regex проверяет: день (01-31), месяц (01-12), год (1000-9999). `LocalDate.of()` автоматически проверяет корректность (например, 31 апреля не существует, високосные годы). При некорректной дате выбрасывается `DateTimeParseException`, который перехватывается и возвращается false.

### Задание 5: Валидация email
**Файл:** `practika25/task5/Main.java`

**Описание:** Проверка корректности email-адреса.

**Функционал:**
- Проверка формата email через регулярное выражение
- Поддержка стандартного формата: `local-part@domain.tld`

### Задание 6: Проверка пароля
**Файл:** `practika25/task6/Main.java`

**Описание:** Проверка надёжности пароля.

**Требования:**
- Минимум 8 символов
- Хотя бы одна заглавная буква
- Хотя бы одна строчная буква
- Хотя бы одна цифра
- Только буквы, цифры и подчёркивание

**Решение и логика:** Используется комбинация positive lookahead для проверки условий: `^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z0-9_]{8,}$`. Каждый `(?=.*...)` проверяет наличие определённого символа где-то в строке без продвижения указателя. `[a-zA-Z0-9_]{8,}` проверяет, что вся строка состоит только из допустимых символов и имеет длину минимум 8. Lookahead проверки выполняются перед основной проверкой, что позволяет проверить все условия за один проход.

---

## Практика 26: Итераторы и коллекции

**Расположение:** `practika26/src/`

### Задание 1: Инверсия массива через Stack
**Файл:** `practika26/src/task1/Main.java`

**Описание:** Инверсия массива с использованием стека.

**Функционал:**
- Дженерик метод `reverseUsingStack()`
- Использование `Stack` для инверсии порядка элементов
- Работа с массивами различных типов

**Решение и логика:** Используется свойство стека LIFO (Last In, First Out). Все элементы исходного массива последовательно помещаются в стек через `push()`. Затем извлекаются через `pop()` в обратном порядке. Для создания массива нужного типа используется рефлексия: `Array.newInstance(arr.getClass().getComponentType(), arr.length)`. Временная сложность: O(n), пространственная: O(n) для стека и нового массива.

### Задание 2: MyArrayList с итератором
**Файл:** `practika26/src/task2/Main.java`

**Описание:** Реализация списка с поддержкой итератора.

**Классы:**
- `MyList` - интерфейс списка
- `MyArrayList` - реализация списка на массиве
- `MyIterator` - итератор с методом `remove()`

**Функционал:**
- Реализация `Iterable` для поддержки for-each
- Итератор с возможностью удаления элементов
- Безопасное удаление во время итерации

**Решение и логика:** `MyArrayList` реализует `Iterable<T>`, что позволяет использовать for-each цикл. Итератор хранит ссылку на список и текущий индекс. Метод `remove()` в итераторе удаляет элемент по текущему индексу и сдвигает все последующие элементы влево через `System.arraycopy()`. Важно: `remove()` можно вызывать только после `next()`, и только один раз на элемент. При удалении уменьшается размер списка и корректируется индекс. Динамическое расширение массива реализовано через `ensureCapacity()` с удвоением размера при необходимости.

### Задание 3: SimpleList с итератором
**Файл:** `practika26/src/task3/Main.java`

**Описание:** Упрощённая реализация списка с итератором.

**Классы:**
- `SimpleList` - список с методами `add()` и итератором
- `SimpleListIterator` - итератор для обхода списка

**Функционал:**
- Реализация `Iterable`
- Поддержка for-each цикла
- Итератор для ручного обхода

---

## Практика 27: Хеш-таблицы

**Расположение:** `practika27/src/`

### Задание 1: Базовая хеш-таблица
**Файл:** `practika27/src/task1/Main.java`

**Описание:** Реализация базовой хеш-таблицы с методами добавления, поиска и удаления.

**Методы:**
- `hashtabAdd()` - добавление элемента
- `hashtabLookup()` - поиск элемента
- `hashtabDelete()` - удаление элемента

**Решение и логика:** Реализация через массив списков (chaining) для разрешения коллизий. Хеш-функция: полиномиальная `hash = 31 * hash + char` (стандартная для строк в Java). Индекс вычисляется как `hash % buckets.length`. При коллизии элементы с одинаковым хешем хранятся в связном списке в соответствующей корзине. При добавлении проверяется наличие ключа - если есть, обновляется значение. Поиск и удаление выполняются линейным поиском в списке корзины. Временная сложность: O(1) в среднем, O(n) в худшем случае (все элементы в одной корзине). Пространственная: O(n).

### Задания 2-3: Расширенная хеш-таблица
**Файл:** `practika27/src/task2-3/Main.java`

**Описание:** Расширенная реализация хеш-таблицы с демонстрацией работы.

**Функционал:**
- Добавление 10 элементов
- Поиск элементов по ключу
- Удаление элементов
- Подсчёт размера таблицы

### Задание 4: Set и PriorityQueue
**Файл:** `practika27/src/task4/Main.java`

**Описание:** Демонстрация работы с `Set` и `PriorityQueue`.

**Функционал:**
- `HashSet` - хранение уникальных элементов
- `PriorityQueue` - очередь с приоритетом (min-heap)
- Извлечение минимальных элементов

**Решение и логика:** `HashSet` автоматически удаляет дубликаты при добавлении элементов через `add()`. Используется хеш-таблица для быстрого поиска и проверки уникальности. `PriorityQueue` реализует min-heap (куча минимума) - наименьший элемент всегда на вершине. При добавлении через `offer()` элементы автоматически упорядочиваются. `poll()` извлекает и удаляет минимальный элемент, перестраивая кучу. Это демонстрирует различные структуры данных для разных задач: Set для уникальности, PriorityQueue для приоритетной обработки. Временная сложность: HashSet операции O(1) в среднем, PriorityQueue операции O(log n).

---

## Практика 28: Коллекции (Set, Map)

**Расположение:** `practika28/src/`

### Задание 1: HashSet и TreeSet
**Файл:** `practika28/src/task1/Main.java`

**Описание:** Преобразование `HashSet` в `TreeSet` для автоматической сортировки.

**Функционал:**
- Создание `HashSet` с элементами
- Преобразование в `TreeSet` для сортировки
- Альтернативная сортировка через `ArrayList` и `Collections.sort()`

**Решение и логика:** `HashSet` хранит элементы в произвольном порядке (на основе хеша), обеспечивая быстрый доступ O(1). `TreeSet` использует красно-чёрное дерево для автоматической сортировки элементов в порядке возрастания. Конструктор `TreeSet(Collection)` принимает коллекцию и создаёт отсортированное множество. Альтернативный подход: создание `ArrayList` из `HashSet` и сортировка через `Collections.sort()`, который использует алгоритм Timsort (гибрид merge sort и insertion sort). Разница: TreeSet поддерживает порядок автоматически при добавлении (O(log n)), ArrayList требует явной сортировки (O(n log n)), но позволяет изменять порядок.

### Задание 2: Работа с Map
**Файл:** `practika28/src/task2/Main.java`

**Описание:** Работа с `Map` для подсчёта повторений имён и фамилий.

**Класс Solution:**
- `createMap()` - создание карты имя-фамилия
- `getSameFirstNameCount()` - подсчёт повторений имени
- `getSameLastNameCount()` - проверка наличия фамилии

**Решение и логика:** `HashMap` хранит пары ключ-значение, где ключ - фамилия (уникален), значение - имя (может повторяться). `getSameFirstNameCount()` перебирает все значения через `map.values()` и подсчитывает совпадения с заданным именем. `getSameLastNameCount()` использует `containsKey()` для проверки наличия фамилии (возвращает 0 или 1, так как ключи уникальны). Это демонстрирует работу с различными частями Map: ключами (`containsKey()`), значениями (`values()`), и парами (`entrySet()`). Временная сложность: O(n) для подсчёта имён (перебор всех значений), O(1) для проверки фамилии.

### Задание 3: DoubleKeyHashTable
**Файл:** `practika28/src/task3/Main.java`

**Описание:** Реализация хеш-таблицы с ключами типа `Double`.

**Функционал:**
- Хранение пар ключ-значение, где ключ - `Double`
- Обработка особых случаев (`-0.0` и `0.0`)
- Методы: `put()`, `get()`, `containsKey()`, `size()`

**Решение и логика:** Особенность работы с `Double`: обычное сравнение `==` не работает из-за особенностей IEEE 754 (например, `-0.0 == 0.0` даёт true, но это разные значения). Используется `Double.compare(key1, key2) == 0` для корректного сравнения. Хеш-функция: преобразование `double` в `long` через `Double.doubleToLongBits()`, затем смешивание старших и младших битов через XOR и сдвиг. Это обеспечивает равномерное распределение хешей. Реализация через chaining (связные списки) для разрешения коллизий. При добавлении проверяется существование ключа через `Double.compare()` - если найден, обновляется значение, иначе добавляется новый элемент.

---

## Структура проекта

```
practika_TrushinArtem_pvbo0124/
├── practika1/          # Основы Java
├── practika2/          # Классы и объекты
├── practika3/          # Пакеты, обёртки, форматирование
├── practika4/          # Наследование и полиморфизм
├── practika5/          # Графический интерфейс (Swing)
├── practika6/          # Интерфейсы
├── practika7/          # Интерфейсы (продолжение)
├── practika8/          # Рекурсия
├── practika9/          # Алгоритмы сортировки
├── practika10/         # Сортировка студентов
├── practika11/         # Работа с датами и временем
├── practika13/         # Регулярные выражения - телефоны
├── practika14/         # Регулярные выражения - извлечение данных
├── practika18/         # Обработка исключений
├── practika19/         # Пользовательские исключения
├── practika20/         # Дженерики
├── practika21/         # Дженерики и коллекции
├── practika22/         # Стеки
├── practika23/         # Очереди и выражения
├── practika24/         # Паттерны проектирования
├── practika25/         # Регулярные выражения (продолжение)
├── practika26/         # Итераторы и коллекции
├── practika27/         # Хеш-таблицы
└── practika28/         # Коллекции (Set, Map)
```

---

## Технологии

- **Язык:** Java
- **Версия:** Java 8+
- **Библиотеки:**
  - Java Swing (GUI)
  - Java Collections Framework
  - Java Time API (`LocalDate`, `LocalDateTime`)
  - Регулярные выражения (`java.util.regex`)

---

## Автор

Трушин Артём

---

## Примечания

- Все практические работы выполнены в рамках курса "Введение в алгоритмы и структуры данных систем реального времени"
- Код содержит комментарии на русском языке
- Некоторые практики содержат README файлы с дополнительной информацией
